import{r as Je,j as sr}from"./index.Kaz2Qz5E.js";/* @license twgl.js 5.5.4 Copyright (c) 2015, Gregg Tavares All Rights Reserved.
Available via the MIT license.
see: http://github.com/greggman/twgl.js for details */const De=5120,J=5121,we=5122,Le=5123,Me=5124,Oe=5125,ze=5126,ir=32819,ar=32820,cr=33635,ur=5131,fr=33640,lr=35899,mr=35902,dr=36269,xr=34042,ct={};{const e=ct;e[De]=Int8Array,e[J]=Uint8Array,e[we]=Int16Array,e[Le]=Uint16Array,e[Me]=Int32Array,e[Oe]=Uint32Array,e[ze]=Float32Array,e[ir]=Uint16Array,e[ar]=Uint16Array,e[cr]=Uint16Array,e[ur]=Uint16Array,e[fr]=Uint32Array,e[lr]=Uint32Array,e[mr]=Uint32Array,e[dr]=Uint32Array,e[xr]=Uint32Array}function Ge(e){if(e instanceof Int8Array)return De;if(e instanceof Uint8Array||e instanceof Uint8ClampedArray)return J;if(e instanceof Int16Array)return we;if(e instanceof Uint16Array)return Le;if(e instanceof Int32Array)return Me;if(e instanceof Uint32Array)return Oe;if(e instanceof Float32Array)return ze;throw new Error("unsupported typed array type")}function ut(e){if(e===Int8Array)return De;if(e===Uint8Array||e===Uint8ClampedArray)return J;if(e===Int16Array)return we;if(e===Uint16Array)return Le;if(e===Int32Array)return Me;if(e===Uint32Array)return Oe;if(e===Float32Array)return ze;throw new Error("unsupported typed array type")}function ft(e){const t=ct[e];if(!t)throw new Error("unknown gl type");return t}const ae=typeof SharedArrayBuffer<"u"?function(t){return t&&t.buffer&&(t.buffer instanceof ArrayBuffer||t.buffer instanceof SharedArrayBuffer)}:function(t){return t&&t.buffer&&t.buffer instanceof ArrayBuffer};function lt(...e){console.error(...e)}const Qe=new Map;function ge(e,t){if(!e||typeof e!="object")return!1;let r=Qe.get(t);r||(r=new WeakMap,Qe.set(t,r));let n=r.get(e);if(n===void 0){const o=Object.prototype.toString.call(e);n=o.substring(8,o.length-1)===t,r.set(e,n)}return n}function yr(e,t){return typeof WebGLBuffer<"u"&&ge(t,"WebGLBuffer")}function mt(e,t){return typeof WebGLTexture<"u"&&ge(t,"WebGLTexture")}function Er(e,t){return typeof WebGLSampler<"u"&&ge(t,"WebGLSampler")}const dt=35044,V=34962,br=34963,Tr=34660,Ar=5120,Rr=5121,pr=5122,_r=5123,Sr=5124,Fr=5125,xt=5126,yt={attribPrefix:""};function hr(e,t,r,n,o){e.bindBuffer(t,r),e.bufferData(t,n,o||dt)}function Et(e,t,r,n){if(yr(e,t))return t;r=r||V;const o=e.createBuffer();return hr(e,r,o,t,n),o}function bt(e){return e==="indices"}function Ir(e){return e===Int8Array||e===Uint8Array}function Pr(e){return e.length?e:e.data}const vr=/coord|texture/i,Ur=/color|colour/i;function Nr(e,t){let r;if(vr.test(e)?r=2:Ur.test(e)?r=4:r=3,t%r>0)throw new Error("Can not guess numComponents for attribute '".concat(e,"'. Tried ").concat(r," but ").concat(t," values is not evenly divisible by ").concat(r,". You should specify it."));return r}function Cr(e,t,r){return e.numComponents||e.size||Nr(t,r||Pr(e).length)}function Tt(e,t){if(ae(e))return e;if(ae(e.data))return e.data;Array.isArray(e)&&(e={data:e});let r=e.type?$e(e.type):void 0;return r||(bt(t)?r=Uint16Array:r=Float32Array),new r(e.data)}function Br(e){return typeof e=="number"?e:e?ut(e):xt}function $e(e){return typeof e=="number"?ft(e):e||Float32Array}function Dr(e,t){return{buffer:t.buffer,numValues:2*3*4,type:Br(t.type),arrayType:$e(t.type)}}function wr(e,t){const r=t.data||t,n=$e(t.type),o=r*n.BYTES_PER_ELEMENT,s=e.createBuffer();return e.bindBuffer(V,s),e.bufferData(V,o,t.drawType||dt),{buffer:s,numValues:r,type:ut(n),arrayType:n}}function Lr(e,t,r){const n=Tt(t,r);return{arrayType:n.constructor,buffer:Et(e,n,void 0,t.drawType),type:Ge(n),numValues:0}}function Mr(e,t){const r={};return Object.keys(t).forEach(function(n){if(!bt(n)){const o=t[n],s=o.attrib||o.name||o.attribName||yt.attribPrefix+n;if(o.value){if(!Array.isArray(o.value)&&!ae(o.value))throw new Error("array.value is not array or typedarray");r[s]={value:o.value}}else{let c;o.buffer&&o.buffer instanceof WebGLBuffer?c=Dr:typeof o=="number"||typeof o.data=="number"?c=wr:c=Lr;const{buffer:i,type:a,numValues:u,arrayType:m}=c(e,o,n),l=o.normalize!==void 0?o.normalize:Ir(m),d=Cr(o,n,u);r[s]={buffer:i,numComponents:d,type:a,normalize:l,stride:o.stride||0,offset:o.offset||0,divisor:o.divisor===void 0?void 0:o.divisor,drawType:o.drawType}}}}),e.bindBuffer(V,null),r}function Or(e,t){return t===Ar||t===Rr?1:t===pr||t===_r?2:t===Sr||t===Fr||t===xt?4:0}const Re=["position","positions","a_position"];function zr(e,t){let r,n;for(n=0;n<Re.length&&(r=Re[n],!(r in t||(r=yt.attribPrefix+r,r in t)));++n);n===Re.length&&(r=Object.keys(t)[0]);const o=t[r];if(!o.buffer)return 1;e.bindBuffer(V,o.buffer);const s=e.getBufferParameter(V,Tr);e.bindBuffer(V,null);const c=Or(e,o.type),i=s/c,a=o.numComponents||o.size,u=i/a;if(u%1!==0)throw new Error("numComponents ".concat(a," not correct for length ").concat(length));return u}function Gr(e,t,r){const n=Mr(e,t),o=Object.assign({},r||{});o.attribs=Object.assign({},r?r.attribs:{},n);const s=t.indices;if(s){const c=Tt(s,"indices");o.indices=Et(e,c,br),o.numElements=c.length,o.elementType=Ge(c)}else o.numElements||(o.numElements=zr(e,o.attribs));return o}function te(e){return!!e.texStorage2D}const At=function(){const e={},t={};function r(n){const o=n.constructor.name;if(!e[o]){for(const s in n)if(typeof n[s]=="number"){const c=t[n[s]];t[n[s]]=c?"".concat(c," | ").concat(s):s}e[o]=!0}}return function(o,s){return r(o),t[s]||(typeof s=="number"?"0x".concat(s.toString(16)):s)}}(),L={textureColor:new Uint8Array([128,192,255,255]),textureOptions:{},crossOrigin:void 0},Q=ae,Rt=function(){let e;return function(){return e=e||(typeof document<"u"&&document.createElement?document.createElement("canvas").getContext("2d"):null),e}}(),Se=6406,v=6407,A=6408,Fe=6409,he=6410,W=6402,Ie=34041,ce=33071,gr=9728,$r=9729,M=3553,w=34067,X=32879,H=35866,ke=34069,kr=34070,Vr=34071,Xr=34072,Hr=34073,Yr=34074,Pe=10241,ve=10240,ue=10242,fe=10243,et=32882,Wr=33082,Kr=33083,jr=33084,Zr=33085,qr=34892,Jr=34893,Ve=3317,pt=3314,_t=32878,St=3316,Ft=3315,ht=32877,Qr=37443,en=37441,tn=37440,rn=33321,nn=36756,on=33325,sn=33326,an=33330,cn=33329,un=33338,fn=33337,ln=33340,mn=33339,dn=33323,xn=36757,yn=33327,En=33328,bn=33336,Tn=33335,An=33332,Rn=33331,pn=33334,_n=33333,Sn=32849,Fn=35905,hn=36194,In=36758,Pn=35898,vn=35901,Un=34843,Nn=34837,Cn=36221,Bn=36239,Dn=36215,wn=36233,Ln=36209,Mn=36227,On=32856,zn=35907,Gn=36759,gn=32855,$n=32854,kn=32857,Vn=34842,Xn=34836,Hn=36220,Yn=36238,Wn=36975,Kn=36214,jn=36232,Zn=36226,qn=36208,Jn=33189,Qn=33190,eo=36012,to=36013,ro=35056,B=5120,R=5121,oe=5122,Y=5123,se=5124,G=5125,F=5126,tt=32819,rt=32820,nt=33635,N=5131,j=36193,pe=33640,no=35899,oo=35902,so=36269,io=34042,Z=33319,g=33320,q=6403,$=36244,k=36248,D=36249,ao={};{const e=ao;e[Se]={numColorComponents:1},e[Fe]={numColorComponents:1},e[he]={numColorComponents:2},e[v]={numColorComponents:3},e[A]={numColorComponents:4},e[q]={numColorComponents:1},e[$]={numColorComponents:1},e[Z]={numColorComponents:2},e[g]={numColorComponents:2},e[v]={numColorComponents:3},e[k]={numColorComponents:3},e[A]={numColorComponents:4},e[D]={numColorComponents:4},e[W]={numColorComponents:1},e[Ie]={numColorComponents:2}}let _e;function me(e){if(!_e){const t={};t[Se]={textureFormat:Se,colorRenderable:!0,textureFilterable:!0,bytesPerElement:[1,2,2,4],type:[R,N,j,F]},t[Fe]={textureFormat:Fe,colorRenderable:!0,textureFilterable:!0,bytesPerElement:[1,2,2,4],type:[R,N,j,F]},t[he]={textureFormat:he,colorRenderable:!0,textureFilterable:!0,bytesPerElement:[2,4,4,8],type:[R,N,j,F]},t[v]={textureFormat:v,colorRenderable:!0,textureFilterable:!0,bytesPerElement:[3,6,6,12,2],type:[R,N,j,F,nt]},t[A]={textureFormat:A,colorRenderable:!0,textureFilterable:!0,bytesPerElement:[4,8,8,16,2,2],type:[R,N,j,F,tt,rt]},t[W]={textureFormat:W,colorRenderable:!0,textureFilterable:!1,bytesPerElement:[2,4],type:[G,Y]},t[rn]={textureFormat:q,colorRenderable:!0,textureFilterable:!0,bytesPerElement:[1],type:[R]},t[nn]={textureFormat:q,colorRenderable:!1,textureFilterable:!0,bytesPerElement:[1],type:[B]},t[on]={textureFormat:q,colorRenderable:!1,textureFilterable:!0,bytesPerElement:[4,2],type:[F,N]},t[sn]={textureFormat:q,colorRenderable:!1,textureFilterable:!1,bytesPerElement:[4],type:[F]},t[an]={textureFormat:$,colorRenderable:!0,textureFilterable:!1,bytesPerElement:[1],type:[R]},t[cn]={textureFormat:$,colorRenderable:!0,textureFilterable:!1,bytesPerElement:[1],type:[B]},t[An]={textureFormat:$,colorRenderable:!0,textureFilterable:!1,bytesPerElement:[2],type:[Y]},t[Rn]={textureFormat:$,colorRenderable:!0,textureFilterable:!1,bytesPerElement:[2],type:[oe]},t[pn]={textureFormat:$,colorRenderable:!0,textureFilterable:!1,bytesPerElement:[4],type:[G]},t[_n]={textureFormat:$,colorRenderable:!0,textureFilterable:!1,bytesPerElement:[4],type:[se]},t[dn]={textureFormat:Z,colorRenderable:!0,textureFilterable:!0,bytesPerElement:[2],type:[R]},t[xn]={textureFormat:Z,colorRenderable:!1,textureFilterable:!0,bytesPerElement:[2],type:[B]},t[yn]={textureFormat:Z,colorRenderable:!1,textureFilterable:!0,bytesPerElement:[8,4],type:[F,N]},t[En]={textureFormat:Z,colorRenderable:!1,textureFilterable:!1,bytesPerElement:[8],type:[F]},t[bn]={textureFormat:g,colorRenderable:!0,textureFilterable:!1,bytesPerElement:[2],type:[R]},t[Tn]={textureFormat:g,colorRenderable:!0,textureFilterable:!1,bytesPerElement:[2],type:[B]},t[un]={textureFormat:g,colorRenderable:!0,textureFilterable:!1,bytesPerElement:[4],type:[Y]},t[fn]={textureFormat:g,colorRenderable:!0,textureFilterable:!1,bytesPerElement:[4],type:[oe]},t[ln]={textureFormat:g,colorRenderable:!0,textureFilterable:!1,bytesPerElement:[8],type:[G]},t[mn]={textureFormat:g,colorRenderable:!0,textureFilterable:!1,bytesPerElement:[8],type:[se]},t[Sn]={textureFormat:v,colorRenderable:!0,textureFilterable:!0,bytesPerElement:[3],type:[R]},t[Fn]={textureFormat:v,colorRenderable:!1,textureFilterable:!0,bytesPerElement:[3],type:[R]},t[hn]={textureFormat:v,colorRenderable:!0,textureFilterable:!0,bytesPerElement:[3,2],type:[R,nt]},t[In]={textureFormat:v,colorRenderable:!1,textureFilterable:!0,bytesPerElement:[3],type:[B]},t[Pn]={textureFormat:v,colorRenderable:!1,textureFilterable:!0,bytesPerElement:[12,6,4],type:[F,N,no]},t[vn]={textureFormat:v,colorRenderable:!1,textureFilterable:!0,bytesPerElement:[12,6,4],type:[F,N,oo]},t[Un]={textureFormat:v,colorRenderable:!1,textureFilterable:!0,bytesPerElement:[12,6],type:[F,N]},t[Nn]={textureFormat:v,colorRenderable:!1,textureFilterable:!1,bytesPerElement:[12],type:[F]},t[Cn]={textureFormat:k,colorRenderable:!1,textureFilterable:!1,bytesPerElement:[3],type:[R]},t[Bn]={textureFormat:k,colorRenderable:!1,textureFilterable:!1,bytesPerElement:[3],type:[B]},t[Dn]={textureFormat:k,colorRenderable:!1,textureFilterable:!1,bytesPerElement:[6],type:[Y]},t[wn]={textureFormat:k,colorRenderable:!1,textureFilterable:!1,bytesPerElement:[6],type:[oe]},t[Ln]={textureFormat:k,colorRenderable:!1,textureFilterable:!1,bytesPerElement:[12],type:[G]},t[Mn]={textureFormat:k,colorRenderable:!1,textureFilterable:!1,bytesPerElement:[12],type:[se]},t[On]={textureFormat:A,colorRenderable:!0,textureFilterable:!0,bytesPerElement:[4],type:[R]},t[zn]={textureFormat:A,colorRenderable:!0,textureFilterable:!0,bytesPerElement:[4],type:[R]},t[Gn]={textureFormat:A,colorRenderable:!1,textureFilterable:!0,bytesPerElement:[4],type:[B]},t[gn]={textureFormat:A,colorRenderable:!0,textureFilterable:!0,bytesPerElement:[4,2,4],type:[R,rt,pe]},t[$n]={textureFormat:A,colorRenderable:!0,textureFilterable:!0,bytesPerElement:[4,2],type:[R,tt]},t[kn]={textureFormat:A,colorRenderable:!0,textureFilterable:!0,bytesPerElement:[4],type:[pe]},t[Vn]={textureFormat:A,colorRenderable:!1,textureFilterable:!0,bytesPerElement:[16,8],type:[F,N]},t[Xn]={textureFormat:A,colorRenderable:!1,textureFilterable:!1,bytesPerElement:[16],type:[F]},t[Hn]={textureFormat:D,colorRenderable:!0,textureFilterable:!1,bytesPerElement:[4],type:[R]},t[Yn]={textureFormat:D,colorRenderable:!0,textureFilterable:!1,bytesPerElement:[4],type:[B]},t[Wn]={textureFormat:D,colorRenderable:!0,textureFilterable:!1,bytesPerElement:[4],type:[pe]},t[Kn]={textureFormat:D,colorRenderable:!0,textureFilterable:!1,bytesPerElement:[8],type:[Y]},t[jn]={textureFormat:D,colorRenderable:!0,textureFilterable:!1,bytesPerElement:[8],type:[oe]},t[Zn]={textureFormat:D,colorRenderable:!0,textureFilterable:!1,bytesPerElement:[16],type:[se]},t[qn]={textureFormat:D,colorRenderable:!0,textureFilterable:!1,bytesPerElement:[16],type:[G]},t[Jn]={textureFormat:W,colorRenderable:!0,textureFilterable:!1,bytesPerElement:[2,4],type:[Y,G]},t[Qn]={textureFormat:W,colorRenderable:!0,textureFilterable:!1,bytesPerElement:[4],type:[G]},t[eo]={textureFormat:W,colorRenderable:!0,textureFilterable:!1,bytesPerElement:[4],type:[F]},t[ro]={textureFormat:Ie,colorRenderable:!0,textureFilterable:!1,bytesPerElement:[4],type:[io]},t[to]={textureFormat:Ie,colorRenderable:!0,textureFilterable:!1,bytesPerElement:[4],type:[so]},Object.keys(t).forEach(function(r){const n=t[r];n.bytesPerElementMap={},n.bytesPerElement.forEach(function(o,s){const c=n.type[s];n.bytesPerElementMap[c]=o})}),_e=t}return _e[e]}function co(e,t){const r=me(e);if(!r)throw"unknown internal format";const n=r.bytesPerElementMap[t];if(n===void 0)throw"unknown internal format";return n}function re(e){const t=me(e);if(!t)throw"unknown internal format";return{format:t.textureFormat,type:t.type[0]}}function ot(e){return(e&e-1)===0}function uo(e,t,r,n){if(!te(e))return ot(t)&&ot(r);const o=me(n);if(!o)throw"unknown internal format";return o.colorRenderable&&o.textureFilterable}function fo(e){const t=me(e);if(!t)throw"unknown internal format";return t.textureFilterable}function lo(e,t,r){return Q(t)?Ge(t):r||R}function ie(e,t,r,n,o){if(o%1!==0)throw"can't guess dimensions";if(!r&&!n){const s=Math.sqrt(o/(t===w?6:1));s%1===0?(r=s,n=s):(r=o,n=1)}else if(n){if(!r&&(r=o/n,r%1))throw"can't guess dimensions"}else if(n=o/r,n%1)throw"can't guess dimensions";return{width:r,height:n}}function K(e,t){t.colorspaceConversion!==void 0&&e.pixelStorei(Qr,t.colorspaceConversion),t.premultiplyAlpha!==void 0&&e.pixelStorei(en,t.premultiplyAlpha),t.flipY!==void 0&&e.pixelStorei(tn,t.flipY)}function It(e){e.pixelStorei(Ve,4),te(e)&&(e.pixelStorei(pt,0),e.pixelStorei(_t,0),e.pixelStorei(St,0),e.pixelStorei(Ft,0),e.pixelStorei(ht,0))}function mo(e,t,r,n){n.minMag&&(r.call(e,t,Pe,n.minMag),r.call(e,t,ve,n.minMag)),n.min&&r.call(e,t,Pe,n.min),n.mag&&r.call(e,t,ve,n.mag),n.wrap&&(r.call(e,t,ue,n.wrap),r.call(e,t,fe,n.wrap),(t===X||Er(e,t))&&r.call(e,t,et,n.wrap)),n.wrapR&&r.call(e,t,et,n.wrapR),n.wrapS&&r.call(e,t,ue,n.wrapS),n.wrapT&&r.call(e,t,fe,n.wrapT),n.minLod!==void 0&&r.call(e,t,Wr,n.minLod),n.maxLod!==void 0&&r.call(e,t,Kr,n.maxLod),n.baseLevel!==void 0&&r.call(e,t,jr,n.baseLevel),n.maxLevel!==void 0&&r.call(e,t,Zr,n.maxLevel),n.compareFunc!==void 0&&r.call(e,t,Jr,n.compareFunc),n.compareMode!==void 0&&r.call(e,t,qr,n.compareMode)}function Pt(e,t,r){const n=r.target||M;e.bindTexture(n,t),mo(e,n,e.texParameteri,r)}function xo(e){return e=e||L.textureColor,Q(e)?e:new Uint8Array([e[0]*255,e[1]*255,e[2]*255,e[3]*255])}function Ue(e,t,r,n,o,s){r=r||L.textureOptions,s=s||A;const c=r.target||M;if(n=n||r.width,o=o||r.height,e.bindTexture(c,t),uo(e,n,o,s))e.generateMipmap(c);else{const i=fo(s)?$r:gr;e.texParameteri(c,Pe,i),e.texParameteri(c,ve,i),e.texParameteri(c,ue,ce),e.texParameteri(c,fe,ce)}}function ee(e){return e.auto===!0||e.auto===void 0&&e.level===void 0}function Ne(e,t){return t=t||{},t.cubeFaceOrder||[ke,kr,Vr,Xr,Hr,Yr]}function Ce(e,t){const n=Ne(e,t).map(function(o,s){return{face:o,ndx:s}});return n.sort(function(o,s){return o.face-s.face}),n}function vt(e,t,r,n){n=n||L.textureOptions;const o=n.target||M,s=n.level||0;let c=r.width,i=r.height;const a=n.internalFormat||n.format||A,u=re(a),m=n.format||u.format,l=n.type||u.type;if(K(e,n),e.bindTexture(o,t),o===w){const d=r.width,E=r.height;let f,y;if(d/6===E)f=E,y=[0,0,1,0,2,0,3,0,4,0,5,0];else if(E/6===d)f=d,y=[0,0,0,1,0,2,0,3,0,4,0,5];else if(d/3===E/2)f=d/3,y=[0,0,1,0,2,0,0,1,1,1,2,1];else if(d/2===E/3)f=d/2,y=[0,0,1,0,0,1,1,1,0,2,1,2];else throw"can't figure out cube map from element: "+(r.src?r.src:r.nodeName);const b=Rt();b?(b.canvas.width=f,b.canvas.height=f,c=f,i=f,Ce(e,n).forEach(function(T){const _=y[T.ndx*2+0]*f,S=y[T.ndx*2+1]*f;b.drawImage(r,_,S,f,f,0,0,f,f),e.texImage2D(T.face,s,a,m,l,b.canvas)}),b.canvas.width=1,b.canvas.height=1):typeof createImageBitmap<"u"&&(c=f,i=f,Ce(e,n).forEach(function(T){const _=y[T.ndx*2+0]*f,S=y[T.ndx*2+1]*f;e.texImage2D(T.face,s,a,f,f,0,m,l,null),createImageBitmap(r,_,S,f,f,{premultiplyAlpha:"none",colorSpaceConversion:"none"}).then(function(U){K(e,n),e.bindTexture(o,t),e.texImage2D(T.face,s,a,m,l,U),ee(n)&&Ue(e,t,n,c,i,a)})}))}else if(o===X||o===H){const d=Math.min(r.width,r.height),E=Math.max(r.width,r.height),f=E/d;if(f%1!==0)throw"can not compute 3D dimensions of element";const y=r.width===E?1:0,b=r.height===E?1:0;e.pixelStorei(Ve,1),e.pixelStorei(pt,r.width),e.pixelStorei(_t,0),e.pixelStorei(ht,0),e.texImage3D(o,s,a,d,d,d,0,m,l,null);for(let T=0;T<f;++T){const _=T*d*y,S=T*d*b;e.pixelStorei(St,_),e.pixelStorei(Ft,S),e.texSubImage3D(o,s,0,0,T,d,d,1,m,l,r)}It(e)}else e.texImage2D(o,s,a,m,l,r);ee(n)&&Ue(e,t,n,c,i,a),Pt(e,t,n)}function ne(){}function yo(e){if(typeof document<"u"){const t=document.createElement("a");return t.href=e,t.hostname===location.hostname&&t.port===location.port&&t.protocol===location.protocol}else{const t=new URL(location.href).origin;return new URL(e,location.href).origin===t}}function Eo(e,t){return t===void 0&&!yo(e)?"anonymous":t}function bo(e,t,r){r=r||ne;let n;if(t=t!==void 0?t:L.crossOrigin,t=Eo(e,t),typeof Image<"u"){n=new Image,t!==void 0&&(n.crossOrigin=t);const o=function(){n.removeEventListener("error",s),n.removeEventListener("load",c),n=null},s=function(){const a="couldn't load image: "+e;lt(a),r(a,n),o()},c=function(){r(null,n),o()};return n.addEventListener("error",s),n.addEventListener("load",c),n.src=e,n}else if(typeof ImageBitmap<"u"){let o,s;const c=function(){r(o,s)},i={};t&&(i.mode="cors"),fetch(e,i).then(function(a){if(!a.ok)throw a;return a.blob()}).then(function(a){return createImageBitmap(a,{premultiplyAlpha:"none",colorSpaceConversion:"none"})}).then(function(a){s=a,setTimeout(c)}).catch(function(a){o=a,setTimeout(c)}),n=null}return n}function Ut(e){return typeof ImageBitmap<"u"&&e instanceof ImageBitmap||typeof ImageData<"u"&&e instanceof ImageData||typeof HTMLElement<"u"&&e instanceof HTMLElement}function Xe(e,t,r){return Ut(e)?(setTimeout(function(){r(null,e)}),e):bo(e,t,r)}function He(e,t,r){r=r||L.textureOptions;const n=r.target||M;if(e.bindTexture(n,t),r.color===!1)return;const o=xo(r.color);if(n===w)for(let s=0;s<6;++s)e.texImage2D(ke+s,0,A,1,1,0,A,R,o);else n===X||n===H?e.texImage3D(n,0,A,1,1,1,0,A,R,o):e.texImage2D(n,0,A,1,1,0,A,R,o)}function To(e,t,r,n){return n=n||ne,r=r||L.textureOptions,He(e,t,r),r=Object.assign({},r),Xe(r.src,r.crossOrigin,function(s,c){s?n(s,t,c):(vt(e,t,c,r),n(null,t,c))})}function Ao(e,t,r,n){n=n||ne;const o=r.src;if(o.length!==6)throw"there must be 6 urls for a cubemap";const s=r.level||0,c=r.internalFormat||r.format||A,i=re(c),a=r.format||i.format,u=r.type||R,m=r.target||M;if(m!==w)throw"target must be TEXTURE_CUBE_MAP";He(e,t,r),r=Object.assign({},r);let l=6;const d=[],E=Ne(e,r);let f;function y(b){return function(T,_){--l,T?d.push(T):_.width!==_.height?d.push("cubemap face img is not a square: "+_.src):(K(e,r),e.bindTexture(m,t),l===5?Ne().forEach(function(S){e.texImage2D(S,s,c,a,u,_)}):e.texImage2D(b,s,c,a,u,_),ee(r)&&e.generateMipmap(m)),l===0&&n(d.length?d:void 0,t,f)}}f=o.map(function(b,T){return Xe(b,r.crossOrigin,y(E[T]))})}function Ro(e,t,r,n){n=n||ne;const o=r.src,s=r.internalFormat||r.format||A,c=re(s),i=r.format||c.format,a=r.type||R,u=r.target||H;if(u!==X&&u!==H)throw"target must be TEXTURE_3D or TEXTURE_2D_ARRAY";He(e,t,r),r=Object.assign({},r);let m=o.length;const l=[];let d;const E=r.level||0;let f=r.width,y=r.height;const b=o.length;let T=!0;function _(S){return function(U,P){if(--m,U)l.push(U);else{if(K(e,r),e.bindTexture(u,t),T){T=!1,f=r.width||P.width,y=r.height||P.height,e.texImage3D(u,E,s,f,y,b,0,i,a,null);for(let z=0;z<b;++z)e.texSubImage3D(u,E,0,0,z,f,y,1,i,a,P)}else{let z=P,C;(P.width!==f||P.height!==y)&&(C=Rt(),z=C.canvas,C.canvas.width=f,C.canvas.height=y,C.drawImage(P,0,0,f,y)),e.texSubImage3D(u,E,0,0,S,f,y,1,i,a,z),C&&z===C.canvas&&(C.canvas.width=0,C.canvas.height=0)}ee(r)&&e.generateMipmap(u)}m===0&&n(l.length?l:void 0,t,d)}}d=o.map(function(S,U){return Xe(S,r.crossOrigin,_(U))})}function po(e,t,r,n){n=n||L.textureOptions;const o=n.target||M;e.bindTexture(o,t);let s=n.width,c=n.height,i=n.depth;const a=n.level||0,u=n.internalFormat||n.format||A,m=re(u),l=n.format||m.format,d=n.type||lo(e,r,m.type);if(Q(r))r instanceof Uint8ClampedArray&&(r=new Uint8Array(r.buffer));else{const b=ft(d);r=new b(r)}const E=co(u,d),f=r.byteLength/E;if(f%1)throw"length wrong size for format: "+At(e,l);let y;if(o===X||o===H)if(!s&&!c&&!i){const b=Math.cbrt(f);if(b%1!==0)throw"can't guess cube size of array of numElements: "+f;s=b,c=b,i=b}else s&&(!c||!i)?(y=ie(e,o,c,i,f/s),c=y.width,i=y.height):c&&(!s||!i)?(y=ie(e,o,s,i,f/c),s=y.width,i=y.height):(y=ie(e,o,s,c,f/i),s=y.width,c=y.height);else y=ie(e,o,s,c,f),s=y.width,c=y.height;if(It(e),e.pixelStorei(Ve,n.unpackAlignment||1),K(e,n),o===w){const b=E/r.BYTES_PER_ELEMENT,T=f/6*b;Ce(e,n).forEach(_=>{const S=T*_.ndx,U=r.subarray(S,S+T);e.texImage2D(_.face,a,u,s,c,0,l,d,U)})}else o===X||o===H?e.texImage3D(o,a,u,s,c,i,0,l,d,r):e.texImage2D(o,a,u,s,c,0,l,d,r);return{width:s,height:c,depth:i,type:d}}function _o(e,t,r){const n=r.target||M;e.bindTexture(n,t);const o=r.level||0,s=r.internalFormat||r.format||A,c=re(s),i=r.format||c.format,a=r.type||c.type;if(K(e,r),n===w)for(let u=0;u<6;++u)e.texImage2D(ke+u,o,s,r.width,r.height,0,i,a,null);else n===X||n===H?e.texImage3D(n,o,s,r.width,r.height,r.depth,0,i,a,null):e.texImage2D(n,o,s,r.width,r.height,0,i,a,null)}function So(e,t,r){r=r||ne,t=t||L.textureOptions;const n=e.createTexture(),o=t.target||M;let s=t.width||1,c=t.height||1;const i=t.internalFormat||A;e.bindTexture(o,n),o===w&&(e.texParameteri(o,ue,ce),e.texParameteri(o,fe,ce));let a=t.src;if(a)if(typeof a=="function"&&(a=a(e,t)),typeof a=="string")To(e,n,t,r);else if(Q(a)||Array.isArray(a)&&(typeof a[0]=="number"||Array.isArray(a[0])||Q(a[0]))){const u=po(e,n,a,t);s=u.width,c=u.height}else Array.isArray(a)&&(typeof a[0]=="string"||Ut(a[0]))?o===w?Ao(e,n,t,r):Ro(e,n,t,r):(vt(e,n,a,t),s=a.width,c=a.height);else _o(e,n,t);return ee(t)&&Ue(e,n,t,s,c,i),Pt(e,n,t),n}const Ye=lt;function Nt(e){return typeof document<"u"&&document.getElementById?document.getElementById(e):null}const le=33984,de=34962,Fo=34963,ho=35713,Io=35714,Po=35632,vo=35633,Uo=35981,Ct=35718,No=35721,Co=35971,Bo=35382,Do=35396,wo=35398,Lo=35392,Mo=35395,xe=5126,Bt=35664,Dt=35665,wt=35666,We=5124,Lt=35667,Mt=35668,Ot=35669,zt=35670,Gt=35671,gt=35672,$t=35673,kt=35674,Vt=35675,Xt=35676,Oo=35678,zo=35680,Go=35679,go=35682,$o=35685,ko=35686,Vo=35687,Xo=35688,Ho=35689,Yo=35690,Wo=36289,Ko=36292,jo=36293,Ke=5125,Ht=36294,Yt=36295,Wt=36296,Zo=36298,qo=36299,Jo=36300,Qo=36303,es=36306,ts=36307,rs=36308,ns=36311,ye=3553,Ee=34067,je=32879,be=35866,x={};function Kt(e,t){return x[t].bindPoint}function os(e,t){return function(r){e.uniform1f(t,r)}}function ss(e,t){return function(r){e.uniform1fv(t,r)}}function is(e,t){return function(r){e.uniform2fv(t,r)}}function as(e,t){return function(r){e.uniform3fv(t,r)}}function cs(e,t){return function(r){e.uniform4fv(t,r)}}function jt(e,t){return function(r){e.uniform1i(t,r)}}function Zt(e,t){return function(r){e.uniform1iv(t,r)}}function qt(e,t){return function(r){e.uniform2iv(t,r)}}function Jt(e,t){return function(r){e.uniform3iv(t,r)}}function Qt(e,t){return function(r){e.uniform4iv(t,r)}}function us(e,t){return function(r){e.uniform1ui(t,r)}}function fs(e,t){return function(r){e.uniform1uiv(t,r)}}function ls(e,t){return function(r){e.uniform2uiv(t,r)}}function ms(e,t){return function(r){e.uniform3uiv(t,r)}}function ds(e,t){return function(r){e.uniform4uiv(t,r)}}function xs(e,t){return function(r){e.uniformMatrix2fv(t,!1,r)}}function ys(e,t){return function(r){e.uniformMatrix3fv(t,!1,r)}}function Es(e,t){return function(r){e.uniformMatrix4fv(t,!1,r)}}function bs(e,t){return function(r){e.uniformMatrix2x3fv(t,!1,r)}}function Ts(e,t){return function(r){e.uniformMatrix3x2fv(t,!1,r)}}function As(e,t){return function(r){e.uniformMatrix2x4fv(t,!1,r)}}function Rs(e,t){return function(r){e.uniformMatrix4x2fv(t,!1,r)}}function ps(e,t){return function(r){e.uniformMatrix3x4fv(t,!1,r)}}function _s(e,t){return function(r){e.uniformMatrix4x3fv(t,!1,r)}}function h(e,t,r,n){const o=Kt(e,t);return te(e)?function(s){let c,i;!s||mt(e,s)?(c=s,i=null):(c=s.texture,i=s.sampler),e.uniform1i(n,r),e.activeTexture(le+r),e.bindTexture(o,c),e.bindSampler(r,i)}:function(s){e.uniform1i(n,r),e.activeTexture(le+r),e.bindTexture(o,s)}}function I(e,t,r,n,o){const s=Kt(e,t),c=new Int32Array(o);for(let i=0;i<o;++i)c[i]=r+i;return te(e)?function(i){e.uniform1iv(n,c),i.forEach(function(a,u){e.activeTexture(le+c[u]);let m,l;!a||mt(e,a)?(m=a,l=null):(m=a.texture,l=a.sampler),e.bindSampler(r,l),e.bindTexture(s,m)})}:function(i){e.uniform1iv(n,c),i.forEach(function(a,u){e.activeTexture(le+c[u]),e.bindTexture(s,a)})}}x[xe]={Type:Float32Array,size:4,setter:os,arraySetter:ss};x[Bt]={Type:Float32Array,size:8,setter:is,cols:2};x[Dt]={Type:Float32Array,size:12,setter:as,cols:3};x[wt]={Type:Float32Array,size:16,setter:cs,cols:4};x[We]={Type:Int32Array,size:4,setter:jt,arraySetter:Zt};x[Lt]={Type:Int32Array,size:8,setter:qt,cols:2};x[Mt]={Type:Int32Array,size:12,setter:Jt,cols:3};x[Ot]={Type:Int32Array,size:16,setter:Qt,cols:4};x[Ke]={Type:Uint32Array,size:4,setter:us,arraySetter:fs};x[Ht]={Type:Uint32Array,size:8,setter:ls,cols:2};x[Yt]={Type:Uint32Array,size:12,setter:ms,cols:3};x[Wt]={Type:Uint32Array,size:16,setter:ds,cols:4};x[zt]={Type:Uint32Array,size:4,setter:jt,arraySetter:Zt};x[Gt]={Type:Uint32Array,size:8,setter:qt,cols:2};x[gt]={Type:Uint32Array,size:12,setter:Jt,cols:3};x[$t]={Type:Uint32Array,size:16,setter:Qt,cols:4};x[kt]={Type:Float32Array,size:32,setter:xs,rows:2,cols:2};x[Vt]={Type:Float32Array,size:48,setter:ys,rows:3,cols:3};x[Xt]={Type:Float32Array,size:64,setter:Es,rows:4,cols:4};x[$o]={Type:Float32Array,size:32,setter:bs,rows:2,cols:3};x[ko]={Type:Float32Array,size:32,setter:As,rows:2,cols:4};x[Vo]={Type:Float32Array,size:48,setter:Ts,rows:3,cols:2};x[Xo]={Type:Float32Array,size:48,setter:ps,rows:3,cols:4};x[Ho]={Type:Float32Array,size:64,setter:Rs,rows:4,cols:2};x[Yo]={Type:Float32Array,size:64,setter:_s,rows:4,cols:3};x[Oo]={Type:null,size:0,setter:h,arraySetter:I,bindPoint:ye};x[zo]={Type:null,size:0,setter:h,arraySetter:I,bindPoint:Ee};x[Go]={Type:null,size:0,setter:h,arraySetter:I,bindPoint:je};x[go]={Type:null,size:0,setter:h,arraySetter:I,bindPoint:ye};x[Wo]={Type:null,size:0,setter:h,arraySetter:I,bindPoint:be};x[Ko]={Type:null,size:0,setter:h,arraySetter:I,bindPoint:be};x[jo]={Type:null,size:0,setter:h,arraySetter:I,bindPoint:Ee};x[Zo]={Type:null,size:0,setter:h,arraySetter:I,bindPoint:ye};x[qo]={Type:null,size:0,setter:h,arraySetter:I,bindPoint:je};x[Jo]={Type:null,size:0,setter:h,arraySetter:I,bindPoint:Ee};x[Qo]={Type:null,size:0,setter:h,arraySetter:I,bindPoint:be};x[es]={Type:null,size:0,setter:h,arraySetter:I,bindPoint:ye};x[ts]={Type:null,size:0,setter:h,arraySetter:I,bindPoint:je};x[rs]={Type:null,size:0,setter:h,arraySetter:I,bindPoint:Ee};x[ns]={Type:null,size:0,setter:h,arraySetter:I,bindPoint:be};function Te(e,t){return function(r){if(r.value)switch(e.disableVertexAttribArray(t),r.value.length){case 4:e.vertexAttrib4fv(t,r.value);break;case 3:e.vertexAttrib3fv(t,r.value);break;case 2:e.vertexAttrib2fv(t,r.value);break;case 1:e.vertexAttrib1fv(t,r.value);break;default:throw new Error("the length of a float constant value must be between 1 and 4!")}else e.bindBuffer(de,r.buffer),e.enableVertexAttribArray(t),e.vertexAttribPointer(t,r.numComponents||r.size,r.type||xe,r.normalize||!1,r.stride||0,r.offset||0),e.vertexAttribDivisor&&e.vertexAttribDivisor(t,r.divisor||0)}}function O(e,t){return function(r){if(r.value)if(e.disableVertexAttribArray(t),r.value.length===4)e.vertexAttrib4iv(t,r.value);else throw new Error("The length of an integer constant value must be 4!");else e.bindBuffer(de,r.buffer),e.enableVertexAttribArray(t),e.vertexAttribIPointer(t,r.numComponents||r.size,r.type||We,r.stride||0,r.offset||0),e.vertexAttribDivisor&&e.vertexAttribDivisor(t,r.divisor||0)}}function Ae(e,t){return function(r){if(r.value)if(e.disableVertexAttribArray(t),r.value.length===4)e.vertexAttrib4uiv(t,r.value);else throw new Error("The length of an unsigned integer constant value must be 4!");else e.bindBuffer(de,r.buffer),e.enableVertexAttribArray(t),e.vertexAttribIPointer(t,r.numComponents||r.size,r.type||Ke,r.stride||0,r.offset||0),e.vertexAttribDivisor&&e.vertexAttribDivisor(t,r.divisor||0)}}function Ze(e,t,r){const n=r.size,o=r.count;return function(s){e.bindBuffer(de,s.buffer);const c=s.size||s.numComponents||n,i=c/o,a=s.type||xe,m=x[a].size*c,l=s.normalize||!1,d=s.offset||0,E=m/o;for(let f=0;f<o;++f)e.enableVertexAttribArray(t+f),e.vertexAttribPointer(t+f,i,a,l,m,d+E*f),e.vertexAttribDivisor&&e.vertexAttribDivisor(t+f,s.divisor||0)}}const p={};p[xe]={size:4,setter:Te};p[Bt]={size:8,setter:Te};p[Dt]={size:12,setter:Te};p[wt]={size:16,setter:Te};p[We]={size:4,setter:O};p[Lt]={size:8,setter:O};p[Mt]={size:12,setter:O};p[Ot]={size:16,setter:O};p[Ke]={size:4,setter:Ae};p[Ht]={size:8,setter:Ae};p[Yt]={size:12,setter:Ae};p[Wt]={size:16,setter:Ae};p[zt]={size:4,setter:O};p[Gt]={size:8,setter:O};p[gt]={size:12,setter:O};p[$t]={size:16,setter:O};p[kt]={size:4,setter:Ze,count:2};p[Vt]={size:9,setter:Ze,count:3};p[Xt]={size:16,setter:Ze,count:4};const Ss=/ERROR:\s*\d+:(\d+)/gi;function Fs(e,t="",r=0){const n=[...t.matchAll(Ss)],o=new Map(n.map((s,c)=>{const i=parseInt(s[1]),a=n[c+1],u=a?a.index:t.length,m=t.substring(s.index,u);return[i-1,m]}));return e.split("\n").map((s,c)=>{const i=o.get(c);return"".concat(c+1+r,": ").concat(s).concat(i?"\n\n^^^ ".concat(i):"")}).join("\n")}const st=/^[ \t]*\n/;function er(e){let t=0;return st.test(e)&&(t=1,e=e.replace(st,"")),{lineOffset:t,shaderSource:e}}function hs(e,t){return e.errorCallback(t),e.callback&&setTimeout(()=>{e.callback("".concat(t,"\n").concat(e.errors.join("\n")))}),null}function Is(e,t,r,n){if(n=n||Ye,!e.getShaderParameter(r,ho)){const s=e.getShaderInfoLog(r),{lineOffset:c,shaderSource:i}=er(e.getShaderSource(r)),a="".concat(Fs(i,s,c),"\nError compiling ").concat(At(e,t),": ").concat(s);return n(a),a}return""}function qe(e,t,r){let n,o,s;if(typeof t=="function"&&(r=t,t=void 0),typeof e=="function")r=e,e=void 0;else if(e&&!Array.isArray(e)){const u=e;r=u.errorCallback,e=u.attribLocations,n=u.transformFeedbackVaryings,o=u.transformFeedbackMode,s=u.callback}const c=r||Ye,i=[],a={errorCallback(u,...m){i.push(u),c(u,...m)},transformFeedbackVaryings:n,transformFeedbackMode:o,callback:s,errors:i};{let u={};Array.isArray(e)?e.forEach(function(m,l){u[m]=t?t[l]:l}):u=e||{},a.attribLocations=u}return a}const Ps=["VERTEX_SHADER","FRAGMENT_SHADER"];function vs(e,t){if(t.indexOf("frag")>=0)return Po;if(t.indexOf("vert")>=0)return vo}function Us(e,t,r){const n=e.getAttachedShaders(t);for(const o of n)r.has(o)&&e.deleteShader(o);e.deleteProgram(t)}const Ns=(e=0)=>new Promise(t=>setTimeout(t,e));function Cs(e,t,r){const n=e.createProgram(),{attribLocations:o,transformFeedbackVaryings:s,transformFeedbackMode:c}=qe(r);for(let i=0;i<t.length;++i){let a=t[i];if(typeof a=="string"){const u=Nt(a),m=u?u.text:a;let l=e[Ps[i]];u&&u.type&&(l=vs(e,u.type)||l),a=e.createShader(l),e.shaderSource(a,er(m).shaderSource),e.compileShader(a),e.attachShader(n,a)}}Object.entries(o).forEach(([i,a])=>e.bindAttribLocation(n,a,i));{let i=s;i&&(i.attribs&&(i=i.attribs),Array.isArray(i)||(i=Object.keys(i)),e.transformFeedbackVaryings(n,i,c||Uo))}return e.linkProgram(n),n}function Bs(e,t,r,n,o){const s=qe(r,n,o),c=new Set(t),i=Cs(e,t,s);function a(u,m){const l=ws(u,m,s.errorCallback);return l&&Us(u,m,c),l}if(s.callback){Ds(e,i).then(()=>{const u=a(e,i);s.callback(u,u?void 0:i)});return}return a(e,i)?void 0:i}async function Ds(e,t){const r=e.getExtension("KHR_parallel_shader_compile"),n=r?(s,c)=>s.getProgramParameter(c,r.COMPLETION_STATUS_KHR):()=>!0;let o=0;do await Ns(o),o=1e3/60;while(!n(e,t))}function ws(e,t,r){if(r=r||Ye,!e.getProgramParameter(t,Io)){const o=e.getProgramInfoLog(t);r("Error in program linking: ".concat(o));const c=e.getAttachedShaders(t).map(i=>Is(e,e.getShaderParameter(i,e.SHADER_TYPE),i,r));return"".concat(o,"\n").concat(c.filter(i=>i).join("\n"))}}function Ls(e,t,r,n,o){return Bs(e,t,r,n,o)}function tr(e){const t=e.name;return t.startsWith("gl_")||t.startsWith("webgl_")}const Ms=/(\.|\[|]|\w+)/g,Os=e=>e>="0"&&e<="9";function zs(e,t,r,n){const o=e.split(Ms).filter(i=>i!=="");let s=0,c="";for(;;){const i=o[s++];c+=i;const a=Os(i[0]),u=a?parseInt(i):i;if(a&&(c+=o[s++]),s===o.length){r[u]=t;break}else{const l=o[s++],d=l==="[",E=r[u]||(d?[]:{});r[u]=E,r=E,n[c]=n[c]||function(f){return function(y){rr(f,y)}}(E),c+=l}}}function Gs(e,t){let r=0;function n(i,a,u){const m=a.name.endsWith("[0]"),l=a.type,d=x[l];if(!d)throw new Error("unknown type: 0x".concat(l.toString(16)));let E;if(d.bindPoint){const f=r;r+=a.size,m?E=d.arraySetter(e,l,f,u,a.size):E=d.setter(e,l,f,u,a.size)}else d.arraySetter&&m?E=d.arraySetter(e,u):E=d.setter(e,u);return E.location=u,E}const o={},s={},c=e.getProgramParameter(t,Ct);for(let i=0;i<c;++i){const a=e.getActiveUniform(t,i);if(tr(a))continue;let u=a.name;u.endsWith("[0]")&&(u=u.substr(0,u.length-3));const m=e.getUniformLocation(t,a.name);if(m){const l=n(t,a,m);o[u]=l,zs(u,l,s,o)}}return o}function gs(e,t){const r={},n=e.getProgramParameter(t,Co);for(let o=0;o<n;++o){const s=e.getTransformFeedbackVarying(t,o);r[s.name]={index:o,type:s.type,size:s.size}}return r}function $s(e,t){const r=e.getProgramParameter(t,Ct),n=[],o=[];for(let i=0;i<r;++i){o.push(i),n.push({});const a=e.getActiveUniform(t,i);n[i].name=a.name}[["UNIFORM_TYPE","type"],["UNIFORM_SIZE","size"],["UNIFORM_BLOCK_INDEX","blockNdx"],["UNIFORM_OFFSET","offset"]].forEach(function(i){const a=i[0],u=i[1];e.getActiveUniforms(t,o,e[a]).forEach(function(m,l){n[l][u]=m})});const s={},c=e.getProgramParameter(t,Bo);for(let i=0;i<c;++i){const a=e.getActiveUniformBlockName(t,i),u={index:e.getUniformBlockIndex(t,a),usedByVertexShader:e.getActiveUniformBlockParameter(t,i,Do),usedByFragmentShader:e.getActiveUniformBlockParameter(t,i,wo),size:e.getActiveUniformBlockParameter(t,i,Lo),uniformIndices:e.getActiveUniformBlockParameter(t,i,Mo)};u.used=u.usedByVertexShader||u.usedByFragmentShader,s[a]=u}return{blockSpecs:s,uniformData:n}}function rr(e,t){for(const r in t){const n=e[r];typeof n=="function"?n(t[r]):rr(e[r],t[r])}}function Be(e,...t){const r=e.uniformSetters||e,n=t.length;for(let o=0;o<n;++o){const s=t[o];if(Array.isArray(s)){const c=s.length;for(let i=0;i<c;++i)Be(r,s[i])}else for(const c in s){const i=r[c];i&&i(s[c])}}}function ks(e,t){const r={},n=e.getProgramParameter(t,No);for(let o=0;o<n;++o){const s=e.getActiveAttrib(t,o);if(tr(s))continue;const c=e.getAttribLocation(t,s.name),i=p[s.type],a=i.setter(e,c,i);a.location=c,r[s.name]=a}return r}function Vs(e,t){for(const r in t){const n=e[r];n&&n(t[r])}}function Xs(e,t,r){r.vertexArrayObject?e.bindVertexArray(r.vertexArrayObject):(Vs(t.attribSetters||t,r.attribs),r.indices&&e.bindBuffer(Fo,r.indices))}function it(e,t){const r=Gs(e,t),n=ks(e,t),o={program:t,uniformSetters:r,attribSetters:n};return te(e)&&(o.uniformBlockSpec=$s(e,t),o.transformFeedbackInfo=gs(e,t)),o}const Hs=/\s|{|}|;/;function Ys(e,t,r,n,o){const s=qe(r,n,o),c=[];if(t=t.map(function(u){if(!Hs.test(u)){const m=Nt(u);if(m)u=m.text;else{const l="no element with id: ".concat(u);s.errorCallback(l),c.push(l)}}return u}),c.length)return hs(s,"");const i=s.callback;i&&(s.callback=(u,m)=>{i(u,u?void 0:it(e,m))});const a=Ls(e,t,s);return a?it(e,a):null}const Ws=4,at=5123;function Ks(e,t,r,n,o,s){r=r===void 0?Ws:r;const c=t.indices,i=t.elementType,a=n===void 0?t.numElements:n;o=o===void 0?0:o,i||c?s!==void 0?e.drawElementsInstanced(r,a,i===void 0?at:t.elementType,o,s):e.drawElements(r,a,i===void 0?at:t.elementType,o):s!==void 0?e.drawArraysInstanced(r,o,a,s):e.drawArrays(r,o,a)}function js(e,t){t=t||1,t=Math.max(0,t);const r=e.clientWidth*t|0,n=e.clientHeight*t|0;return e.width!==r||e.height!==n?(e.width=r,e.height=n,!0):!1}const Zs="/png/30a1f9046c82d246.BOFplHmk.png",nr="#version 300 es\n\nprecision mediump float;\n\nflat in float speedX;\nflat in float speedY;\nflat in float reverse;\nuniform float uPi;\nuniform vec2 uResolution;\nuniform sampler2D uTexture;\nout vec4 color;\n\nmat3 rotate(float angle) {\n    return transpose(mat3(\n            cos(angle), -sin(angle), 0.,\n            sin(angle), cos(angle), 0.,\n            0., 0., 1.\n        ));\n}\n\nconst mat3 transCenter = transpose(mat3(\n            1., 0., -.5,\n            0., 1., -.5,\n            0., 0., 1.\n        ));\n\nconst mat3 transBack = transpose(mat3(\n            1., 0., .5,\n            0., 1., .5,\n            0., 0., 1.\n        ));\n\nvoid main() {\n    vec3 texCoord;\n\n    float rad;\n    if (speedX < 0.) {\n        rad = uPi * reverse - (reverse - .5) * 2. * atan(speedX * uResolution.x / speedY / uResolution.y);\n    } else if (speedX > 0.) {\n        rad = uPi / 2. + (reverse - .5) * 2. * atan(speedY * uResolution.y / abs(speedX) / uResolution.x);\n    } else {\n        rad = uPi * reverse;\n    }\n    texCoord = transBack * rotate(rad) * transCenter * vec3(gl_PointCoord, 1.);\n\n    if (texCoord.x > 1. || texCoord.x < 0. || texCoord.y > 1. || texCoord.y < 0.) {\n        discard;\n    }\n\n    color = texture(uTexture, texCoord.xy);\n}\n",qs="import {\n  createBufferInfoFromArrays,\n  createProgramInfo,\n  createTexture,\n  drawBufferInfo,\n  resizeCanvasToDisplaySize,\n  setBuffersAndAttributes,\n  setUniforms\n} from 'twgl.js'\nimport fragmentShader from './frag.glsl?raw'\nimport raindropUrl from './raindrop.png'\nimport vertexShader from './vert.glsl?raw'\n\nexport const useRain = (getCanvas: () => HTMLCanvasElement | undefined | null) => {\n  let canvas: HTMLCanvasElement\n  let gl: WebGL2RenderingContext\n  let animationId: number\n  let resizeObserver: ResizeObserver\n\n  // # render\n  const render = (args: { count?: number; speedX?: number; speedY?: number; size?: number }) => {\n    if (args.speedY && args.speedY < 0) {\n      throw new Error('speedY must be positive')\n    }\n\n    // ## gl\n    if (canvas) {\n      dispose()\n    }\n    const dom = getCanvas()\n    if (!dom) {\n      return\n    }\n    canvas = dom\n    const ctx = canvas.getContext('webgl2')\n    if (!ctx) {\n      return\n    }\n    gl = ctx\n\n    // ## program\n    const programInfo = createProgramInfo(gl, [vertexShader, fragmentShader])\n\n    const count = args.count ?? 1e3\n    const bufferInfo = createBufferInfoFromArrays(gl, {\n      position: {\n        numComponents: 2,\n        data: Array.from({ length: count * 2 }).map(() => (Math.random() - 0.5) * 2)\n      },\n      speed: {\n        numComponents: 1,\n        data: Array.from({ length: count }).map(() => Math.random() + 1)\n      }\n    })\n\n    const texture = createTexture(gl, {\n      src: raindropUrl\n    })\n    const uniforms = {\n      uSpeedX: args.speedX ?? 1e-4,\n      uSpeedY: args.speedY ?? 1e-4,\n      uTime: 0,\n      uSize: args.size ?? 5,\n      uResolution: [1, 1],\n      uTexture: texture,\n      uPi: Math.PI\n    }\n\n    gl.useProgram(programInfo.program)\n    setBuffersAndAttributes(gl, programInfo, bufferInfo)\n    setUniforms(programInfo, uniforms)\n\n    // ## animate\n    const animate = (time: number) => {\n      uniforms.uTime = time\n      setUniforms(programInfo, uniforms)\n      drawBufferInfo(gl, bufferInfo, gl.POINTS)\n\n      animationId = requestAnimationFrame(animate)\n    }\n\n    animate(new Date().getTime())\n\n    // ## resize\n    const resize = () => {\n      resizeCanvasToDisplaySize(canvas)\n      const size = canvas.getBoundingClientRect()\n      gl.viewport(0, 0, size.width, size.height)\n      uniforms.uResolution = [size.width, size.height]\n    }\n    resizeObserver = new ResizeObserver(resize)\n    resizeObserver.observe(canvas)\n    resize()\n  }\n\n  // # dispose\n  const dispose = () => {\n    animationId && cancelAnimationFrame(animationId)\n    resizeObserver && resizeObserver.disconnect()\n  }\n\n  return { render, dispose }\n}\n",or="#version 300 es\n\nprecision mediump float;\n\nuniform float uSpeedX;\nuniform float uSpeedY;\nuniform float uTime;\nuniform float uSize;\nuniform float uPi;\nin vec2 position;\nin float speed;\nflat out float speedX;\nflat out float speedY;\n// 1.: true, 0.: false\nflat out float reverse;\n\nvoid main() {\n    gl_PointSize = uSize;\n\n    speedX = uSpeedX * speed;\n    speedY = uSpeedY * speed;\n\n    float x;\n    if (speedX > 0.) {\n        x = (mod(position.x + uTime * speedX, 1.) - .5) * 2.;\n    } else if (speedX < 0.) {\n        x = (.5 - mod(position.x - uTime * speedX, 1.)) * 2.;\n    } else {\n        x = position.x;\n    }\n\n    float y = (.5 - mod(position.y + uTime * speedY, 1.1)) * 2.;\n    reverse = step(y, -1.) * step(-y, 1.1);\n    if (y < -1.) {\n        y = -1. - .05 * sin((y + 1.) * 5. * uPi);\n    }\n\n    gl_Position = vec4(x, y, 0., 1.);\n}\n",Js=e=>{let t,r,n,o;const s=i=>{var T,_,S,U;if(i.speedY&&i.speedY<0)throw new Error("speedY must be positive");t&&c();const a=e();if(!a)return;t=a;const u=t.getContext("webgl2");if(!u)return;r=u;const m=Ys(r,[or,nr]),l=(T=i.count)!=null?T:1e3,d=Gr(r,{position:{numComponents:2,data:Array.from({length:l*2}).map(()=>(Math.random()-.5)*2)},speed:{numComponents:1,data:Array.from({length:l}).map(()=>Math.random()+1)}}),E=So(r,{src:Zs}),f={uSpeedX:(_=i.speedX)!=null?_:1e-4,uSpeedY:(S=i.speedY)!=null?S:1e-4,uTime:0,uSize:(U=i.size)!=null?U:5,uResolution:[1,1],uTexture:E,uPi:Math.PI};r.useProgram(m.program),Xs(r,m,d),Be(m,f);const y=P=>{f.uTime=P,Be(m,f),Ks(r,d,r.POINTS),n=requestAnimationFrame(y)};y(new Date().getTime());const b=()=>{js(t);const P=t.getBoundingClientRect();r.viewport(0,0,P.width,P.height),f.uResolution=[P.width,P.height]};o=new ResizeObserver(b),o.observe(t),b()},c=()=>{n&&cancelAnimationFrame(n),o&&o.disconnect()};return{render:s,dispose:c}},Qs=()=>{const e=Je.useRef(),t={width:"100%",height:"100%",backgroundColor:"#000000"};return Je.useEffect(()=>{if(!e.current)return;const{render:r,dispose:n}=Js(()=>e.current);return r({}),n},[]),sr.jsx("canvas",{ref:e,style:t})},ei="import { useEffect, useRef } from 'react'\nimport { useRain } from './impl'\n\nexport const Rain = () => {\n  const canvasRef = useRef<HTMLCanvasElement>()\n  const canvasStyle = {\n    width: '100%',\n    height: '100%',\n    backgroundColor: '#000000'\n  }\n\n  useEffect(() => {\n    if (!canvasRef.current) {\n      return\n    }\n    const { render, dispose } = useRain(() => canvasRef.current)\n    render({})\n    return dispose\n  }, [])\n\n  return <canvas ref={canvasRef} style={canvasStyle} />\n}\n",ti={id:"rainWebgl",title:"rain",desc:"Rain animation",category:"webgl",tags:["shader","animation"],impl:Qs,code:[{label:"template",filetype:"typescript",content:ei},{label:"script",filetype:"typescript",content:qs},{label:"fragmentShader",filetype:"glsl",content:nr},{label:"vertexShader",filetype:"glsl",content:or}]},ni=[ti];export{ni as default};
